{"dependencies":[{"name":"/Users/yiningshi/dev/tfjs-models/posenet/demos/package.json","includedInParent":true,"mtime":1530912130696},{"name":"/Users/yiningshi/dev/tfjs-models/posenet/demos/.babelrc","includedInParent":true,"mtime":1529855715672},{"name":"/Users/yiningshi/dev/tfjs-models/posenet/tsconfig.json","includedInParent":true,"mtime":1529855715734},{"name":"@tensorflow/tfjs","loc":{"line":3,"column":17}}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs\");\nvar mobileNet100Architecture = [\n    ['conv2d', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1]\n];\nvar mobileNet75Architecture = [\n    ['conv2d', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1]\n];\nvar mobileNet50Architecture = [\n    ['conv2d', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 2],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1],\n    ['separableConv', 1]\n];\nvar VALID_OUTPUT_STRIDES = [8, 16, 32];\nfunction assertValidOutputStride(outputStride) {\n    tf.util.assert(typeof outputStride === 'number', 'outputStride is not a number');\n    tf.util.assert(VALID_OUTPUT_STRIDES.indexOf(outputStride) >= 0, \"outputStride of \" + outputStride + \" is invalid. \" +\n        \"It must be either 8, 16, or 32\");\n}\nexports.assertValidOutputStride = assertValidOutputStride;\nfunction assertValidResolution(resolution, outputStride) {\n    tf.util.assert(typeof resolution === 'number', 'resolution is not a number');\n    tf.util.assert((resolution - 1) % outputStride === 0, \"resolution of \" + resolution + \" is invalid for output stride \" +\n        (outputStride + \".\"));\n}\nexports.assertValidResolution = assertValidResolution;\nfunction assertValidScaleFactor(imageScaleFactor) {\n    tf.util.assert(typeof imageScaleFactor === 'number', 'imageScaleFactor is not a number');\n    tf.util.assert(imageScaleFactor >= 0.2 && imageScaleFactor <= 1.0, 'imageScaleFactor must be between 0.2 and 1.0');\n}\nexports.assertValidScaleFactor = assertValidScaleFactor;\nexports.mobileNetArchitectures = {\n    100: mobileNet100Architecture,\n    75: mobileNet75Architecture,\n    50: mobileNet50Architecture\n};\nfunction toOutputStridedLayers(convolutionDefinition, outputStride) {\n    var currentStride = 1;\n    var rate = 1;\n    return convolutionDefinition.map(function (_a, blockId) {\n        var convType = _a[0], stride = _a[1];\n        var layerStride, layerRate;\n        if (currentStride === outputStride) {\n            layerStride = 1;\n            layerRate = rate;\n            rate *= stride;\n        }\n        else {\n            layerStride = stride;\n            layerRate = 1;\n            currentStride *= stride;\n        }\n        return {\n            blockId: blockId,\n            convType: convType,\n            stride: layerStride,\n            rate: layerRate,\n            outputStride: currentStride\n        };\n    });\n}\nvar MobileNet = (function () {\n    function MobileNet(variables, convolutionDefinitions) {\n        this.PREPROCESS_DIVISOR = tf.scalar(255.0 / 2);\n        this.ONE = tf.scalar(1);\n        this.variables = variables;\n        this.convolutionDefinitions = convolutionDefinitions;\n    }\n    MobileNet.prototype.predict = function (input, outputStride) {\n        var _this = this;\n        var preprocessedInput = tf.cast(input, 'float32').div(this.PREPROCESS_DIVISOR).sub(this.ONE);\n        var layers = toOutputStridedLayers(this.convolutionDefinitions, outputStride);\n        return layers.reduce(function (previousLayer, _a) {\n            var blockId = _a.blockId, stride = _a.stride, convType = _a.convType, rate = _a.rate;\n            if (convType === 'conv2d') {\n                return _this.conv(previousLayer, stride, blockId);\n            }\n            else if (convType === 'separableConv') {\n                return _this.separableConv(previousLayer, stride, blockId, rate);\n            }\n            else {\n                throw Error(\"Unknown conv type of \" + convType);\n            }\n        }, preprocessedInput);\n    };\n    MobileNet.prototype.convToOutput = function (mobileNetOutput, outputLayerName) {\n        return mobileNetOutput.conv2d(this.weights(outputLayerName), 1, 'same')\n            .add(this.biases(outputLayerName));\n    };\n    MobileNet.prototype.conv = function (inputs, stride, blockId) {\n        return inputs\n            .conv2d(this.weights(\"Conv2d_\" + String(blockId)), stride, 'same')\n            .add(this.biases(\"Conv2d_\" + String(blockId)))\n            .clipByValue(0, 6);\n    };\n    MobileNet.prototype.separableConv = function (inputs, stride, blockID, dilations) {\n        if (dilations === void 0) { dilations = 1; }\n        var dwLayer = \"Conv2d_\" + String(blockID) + \"_depthwise\";\n        var pwLayer = \"Conv2d_\" + String(blockID) + \"_pointwise\";\n        var x1 = inputs\n            .depthwiseConv2D(this.depthwiseWeights(dwLayer), stride, 'same', 'NHWC', dilations)\n            .add(this.biases(dwLayer))\n            .clipByValue(0, 6);\n        var x2 = x1.conv2d(this.weights(pwLayer), [1, 1], 'same')\n            .add(this.biases(pwLayer))\n            .clipByValue(0, 6);\n        return x2;\n    };\n    MobileNet.prototype.weights = function (layerName) {\n        return this.variables[\"MobilenetV1/\" + layerName + \"/weights\"];\n    };\n    MobileNet.prototype.biases = function (layerName) {\n        return this.variables[\"MobilenetV1/\" + layerName + \"/biases\"];\n    };\n    MobileNet.prototype.depthwiseWeights = function (layerName) {\n        return this.variables[\"MobilenetV1/\" + layerName + \"/depthwise_weights\"];\n    };\n    MobileNet.prototype.dispose = function () {\n        for (var varName in this.variables) {\n            this.variables[varName].dispose();\n        }\n    };\n    return MobileNet;\n}());\nexports.MobileNet = MobileNet;\n","map":{"version":3,"file":"mobilenet.js","sourceRoot":"","sources":["../src/mobilenet.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\n\nexport type MobileNetMultiplier = 0.50|0.75|1.0|1.01;\nexport type ConvolutionType = 'conv2d'|'separableConv';\nexport type ConvolutionDefinition = [ConvolutionType, number];\nexport type OutputStride = 32|16|8;\n\n// clang-format off\nconst mobileNet100Architecture: ConvolutionDefinition[] = [\n  ['conv2d', 2],\n  ['separableConv', 1],\n  ['separableConv', 2],\n  ['separableConv', 1],\n  ['separableConv', 2],\n  ['separableConv', 1],\n  ['separableConv', 2],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 2],\n  ['separableConv', 1]\n];\n\nconst mobileNet75Architecture: ConvolutionDefinition[]  = [\n  ['conv2d', 2],\n  ['separableConv', 1],\n  ['separableConv', 2],\n  ['separableConv', 1],\n  ['separableConv', 2],\n  ['separableConv', 1],\n  ['separableConv', 2],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1]\n];\n\nconst mobileNet50Architecture: ConvolutionDefinition[]  = [\n  ['conv2d', 2],\n  ['separableConv', 1],\n  ['separableConv', 2],\n  ['separableConv', 1],\n  ['separableConv', 2],\n  ['separableConv', 1],\n  ['separableConv', 2],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1],\n  ['separableConv', 1]\n];\n// clang-format on\n\nconst VALID_OUTPUT_STRIDES = [8, 16, 32];\n// tslint:disable-next-line:no-any\nexport function assertValidOutputStride(outputStride: any) {\n  tf.util.assert(\n      typeof outputStride === 'number', 'outputStride is not a number');\n  tf.util.assert(\n      VALID_OUTPUT_STRIDES.indexOf(outputStride) >= 0,\n      `outputStride of ${outputStride} is invalid. ` +\n          `It must be either 8, 16, or 32`);\n}\n\n// tslint:disable-next-line:no-any\nexport function assertValidResolution(resolution: any, outputStride: number) {\n  tf.util.assert(typeof resolution === 'number', 'resolution is not a number');\n\n  tf.util.assert(\n      (resolution - 1) % outputStride === 0,\n      `resolution of ${resolution} is invalid for output stride ` +\n          `${outputStride}.`);\n}\n\n// tslint:disable-next-line:no-any\nexport function assertValidScaleFactor(imageScaleFactor: any) {\n  tf.util.assert(\n      typeof imageScaleFactor === 'number', 'imageScaleFactor is not a number');\n\n  tf.util.assert(\n      imageScaleFactor >= 0.2 && imageScaleFactor <= 1.0,\n      'imageScaleFactor must be between 0.2 and 1.0');\n}\n\nexport const mobileNetArchitectures:\n    {[name: string]: ConvolutionDefinition[]} = {\n      100: mobileNet100Architecture,\n      75: mobileNet75Architecture,\n      50: mobileNet50Architecture\n    };\n\ntype Layer = {\n  blockId: number,\n  stride: number,\n  outputStride: number,\n  convType: ConvolutionType,\n  rate: number\n};\n\n/**\n * Takes a mobilenet architectures' convolution definitions and converts them\n * into definitions for convolutional layers that will generate outputs with the\n * desired output stride. It does this by reducing the input stride in certain\n * layers and applying atrous convolution in subsequent layers. Raises an error\n * if the output stride is not possible with the architecture.\n */\nfunction toOutputStridedLayers(\n    convolutionDefinition: ConvolutionDefinition[],\n    outputStride: OutputStride): Layer[] {\n  // The currentStride variable keeps track of the output stride of\n  // the activations, i.e., the running product of convolution\n  // strides up to the current network layer. This allows us to\n  // invoke atrous convolution whenever applying the next\n  // convolution would result in the activations having output\n  // stride larger than the target outputStride.\n  let currentStride = 1;\n\n  // The atrous convolution rate parameter.\n  let rate = 1;\n\n  return convolutionDefinition.map(([convType, stride], blockId): Layer => {\n    let layerStride, layerRate;\n\n    if (currentStride === outputStride) {\n      // If we have reached the target outputStride, then we need to\n      // employ atrous convolution with stride=1 and multiply the atrous\n      // rate by the current unit's stride for use in subsequent layers.\n      layerStride = 1;\n      layerRate = rate;\n      rate *= stride;\n    } else {\n      layerStride = stride;\n      layerRate = 1;\n      currentStride *= stride;\n    }\n\n    return {\n      blockId,\n      convType,\n      stride: layerStride,\n      rate: layerRate,\n      outputStride: currentStride\n    };\n  });\n}\n\nexport class MobileNet {\n  private variables: {[varName: string]: tf.Tensor};\n  private convolutionDefinitions: ConvolutionDefinition[];\n\n  private PREPROCESS_DIVISOR = tf.scalar(255.0 / 2);\n  private ONE = tf.scalar(1);\n\n  constructor(\n      variables: {[varName: string]: tf.Tensor},\n      convolutionDefinitions: ConvolutionDefinition[]) {\n    this.variables = variables;\n    this.convolutionDefinitions = convolutionDefinitions;\n  }\n\n  predict(input: tf.Tensor3D, outputStride: OutputStride) {\n    // Normalize the pixels [0, 255] to be between [-1, 1].\n    const preprocessedInput =\n        tf.cast(input, 'float32').div(this.PREPROCESS_DIVISOR).sub(this.ONE) as\n        tf.Tensor3D;\n\n    const layers =\n        toOutputStridedLayers(this.convolutionDefinitions, outputStride);\n\n    return layers.reduce(\n        (previousLayer: tf.Tensor3D,\n         {blockId, stride, convType, rate}: Layer) => {\n          if (convType === 'conv2d') {\n            return this.conv(previousLayer, stride, blockId);\n          } else if (convType === 'separableConv') {\n            return this.separableConv(previousLayer, stride, blockId, rate);\n          } else {\n            throw Error(`Unknown conv type of ${convType}`);\n          }\n        },\n        preprocessedInput);\n  }\n\n  public convToOutput(mobileNetOutput: tf.Tensor3D, outputLayerName: string):\n      tf.Tensor3D {\n    return mobileNetOutput.conv2d(this.weights(outputLayerName), 1, 'same')\n               .add(this.biases(outputLayerName)) as tf.Tensor3D;\n  }\n\n  private conv(inputs: tf.Tensor3D, stride: number, blockId: number):\n      tf.Tensor3D {\n    return inputs\n               .conv2d(\n                   this.weights(`Conv2d_${String(blockId)}`), stride, 'same')\n               .add(this.biases(`Conv2d_${String(blockId)}`))\n               // relu6\n               .clipByValue(0, 6) as tf.Tensor3D;\n  }\n\n  private separableConv(\n      inputs: tf.Tensor3D, stride: number, blockID: number,\n      dilations = 1): tf.Tensor3D {\n    const dwLayer = `Conv2d_${String(blockID)}_depthwise`;\n    const pwLayer = `Conv2d_${String(blockID)}_pointwise`;\n\n    const x1 = inputs\n                   .depthwiseConv2D(\n                       this.depthwiseWeights(dwLayer), stride, 'same', 'NHWC',\n                       dilations)\n                   .add(this.biases(dwLayer))\n                   // relu6\n                   .clipByValue(0, 6) as tf.Tensor3D;\n\n    const x2 = x1.conv2d(this.weights(pwLayer), [1, 1], 'same')\n                   .add(this.biases(pwLayer))\n                   // relu6\n                   .clipByValue(0, 6) as tf.Tensor3D;\n\n    return x2;\n  }\n\n  private weights(layerName: string) {\n    return this.variables[`MobilenetV1/${layerName}/weights`] as tf.Tensor4D;\n  }\n\n  private biases(layerName: string) {\n    return this.variables[`MobilenetV1/${layerName}/biases`] as tf.Tensor1D;\n  }\n\n  private depthwiseWeights(layerName: string) {\n    return this.variables[`MobilenetV1/${layerName}/depthwise_weights`] as\n        tf.Tensor4D;\n  }\n\n  dispose() {\n    for (const varName in this.variables) {\n      this.variables[varName].dispose();\n    }\n  }\n}\n"]}},"hash":"a472cc53a7c8e473314bd0fd10c76196","cacheData":{"env":{}}}