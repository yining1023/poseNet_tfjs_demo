{"dependencies":[{"name":"/Users/yiningshi/dev/tfjs-models/posenet/demos/package.json","includedInParent":true,"mtime":1530912130696},{"name":"/Users/yiningshi/dev/tfjs-models/posenet/demos/.babelrc","includedInParent":true,"mtime":1529855715672},{"name":"/Users/yiningshi/dev/tfjs-models/posenet/tsconfig.json","includedInParent":true,"mtime":1529855715734},{"name":"@tensorflow/tfjs","loc":{"line":3,"column":17}},{"name":"../keypoints","loc":{"line":4,"column":26}}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs\");\nvar keypoints_1 = require(\"../keypoints\");\nfunction getPointsConfidence(heatmapScores, heatMapCoords) {\n    var numKeypoints = heatMapCoords.shape[0];\n    var result = new Float32Array(numKeypoints);\n    for (var keypoint = 0; keypoint < numKeypoints; keypoint++) {\n        var y = heatMapCoords.get(keypoint, 0);\n        var x = heatMapCoords.get(keypoint, 1);\n        result[keypoint] = heatmapScores.get(y, x, keypoint);\n    }\n    return result;\n}\nexports.getPointsConfidence = getPointsConfidence;\nfunction getOffsetPoint(y, x, keypoint, offsetsBuffer) {\n    return {\n        y: offsetsBuffer.get(y, x, keypoint),\n        x: offsetsBuffer.get(y, x, keypoint + keypoints_1.NUM_KEYPOINTS)\n    };\n}\nfunction getOffsetVectors(heatMapCoordsBuffer, offsetsBuffer) {\n    var result = [];\n    for (var keypoint = 0; keypoint < keypoints_1.NUM_KEYPOINTS; keypoint++) {\n        var heatmapY = heatMapCoordsBuffer.get(keypoint, 0).valueOf();\n        var heatmapX = heatMapCoordsBuffer.get(keypoint, 1).valueOf();\n        var _a = getOffsetPoint(heatmapY, heatmapX, keypoint, offsetsBuffer), x = _a.x, y = _a.y;\n        result.push(y);\n        result.push(x);\n    }\n    return tf.tensor2d(result, [keypoints_1.NUM_KEYPOINTS, 2]);\n}\nexports.getOffsetVectors = getOffsetVectors;\nfunction getOffsetPoints(heatMapCoordsBuffer, outputStride, offsetsBuffer) {\n    return tf.tidy(function () {\n        var offsetVectors = getOffsetVectors(heatMapCoordsBuffer, offsetsBuffer);\n        return heatMapCoordsBuffer.toTensor()\n            .mul(tf.scalar(outputStride, 'int32'))\n            .toFloat()\n            .add(offsetVectors);\n    });\n}\nexports.getOffsetPoints = getOffsetPoints;\n","map":{"version":3,"file":"util.js","sourceRoot":"","sources":["../src/singlePose/util.ts"],"names":[],"mappings":";;AAiBA,qCAAuC;AACvC,0CAA2C;AAG3C,6BACI,aAA0C,EAC1C,aAA0C;IAC5C,IAAM,YAAY,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IAC5C,IAAM,MAAM,GAAG,IAAI,YAAY,CAAC,YAAY,CAAC,CAAC;IAE9C,KAAK,IAAI,QAAQ,GAAG,CAAC,EAAE,QAAQ,GAAG,YAAY,EAAE,QAAQ,EAAE,EAAE;QAC1D,IAAM,CAAC,GAAG,aAAa,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QACzC,IAAM,CAAC,GAAG,aAAa,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;QACzC,MAAM,CAAC,QAAQ,CAAC,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;KACtD;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAbD,kDAaC;AAED,wBACI,CAAS,EAAE,CAAS,EAAE,QAAgB,EACtC,aAA0C;IAC5C,OAAO;QACL,CAAC,EAAE,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC;QACpC,CAAC,EAAE,aAAa,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,GAAG,yBAAa,CAAC;KACrD,CAAC;AACJ,CAAC;AAED,0BACI,mBAAgD,EAChD,aAA0C;IAC5C,IAAM,MAAM,GAAa,EAAE,CAAC;IAE5B,KAAK,IAAI,QAAQ,GAAG,CAAC,EAAE,QAAQ,GAAG,yBAAa,EAAE,QAAQ,EAAE,EAAE;QAC3D,IAAM,QAAQ,GAAG,mBAAmB,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;QAChE,IAAM,QAAQ,GAAG,mBAAmB,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC;QAE1D,IAAA,gEAAoE,EAAnE,QAAC,EAAE,QAAC,CAAgE;QAE3E,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACf,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;KAChB;IAED,OAAO,EAAE,CAAC,QAAQ,CAAC,MAAM,EAAE,CAAC,yBAAa,EAAE,CAAC,CAAC,CAAC,CAAC;AACjD,CAAC;AAhBD,4CAgBC;AAED,yBACI,mBAAgD,EAAE,YAAoB,EACtE,aAA0C;IAC5C,OAAO,EAAE,CAAC,IAAI,CAAC;QACb,IAAM,aAAa,GAAG,gBAAgB,CAAC,mBAAmB,EAAE,aAAa,CAAC,CAAC;QAE3E,OAAO,mBAAmB,CAAC,QAAQ,EAAE;aAChC,GAAG,CAAC,EAAE,CAAC,MAAM,CAAC,YAAY,EAAE,OAAO,CAAC,CAAC;aACrC,OAAO,EAAE;aACT,GAAG,CAAC,aAAa,CAAC,CAAC;IAC1B,CAAC,CAAC,CAAC;AACL,CAAC;AAXD,0CAWC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\nimport {NUM_KEYPOINTS} from '../keypoints';\nimport {Vector2D} from '../types';\n\nexport function getPointsConfidence(\n    heatmapScores: tf.TensorBuffer<tf.Rank.R3>,\n    heatMapCoords: tf.TensorBuffer<tf.Rank.R2>): Float32Array {\n  const numKeypoints = heatMapCoords.shape[0];\n  const result = new Float32Array(numKeypoints);\n\n  for (let keypoint = 0; keypoint < numKeypoints; keypoint++) {\n    const y = heatMapCoords.get(keypoint, 0);\n    const x = heatMapCoords.get(keypoint, 1);\n    result[keypoint] = heatmapScores.get(y, x, keypoint);\n  }\n\n  return result;\n}\n\nfunction getOffsetPoint(\n    y: number, x: number, keypoint: number,\n    offsetsBuffer: tf.TensorBuffer<tf.Rank.R3>): Vector2D {\n  return {\n    y: offsetsBuffer.get(y, x, keypoint),\n    x: offsetsBuffer.get(y, x, keypoint + NUM_KEYPOINTS)\n  };\n}\n\nexport function getOffsetVectors(\n    heatMapCoordsBuffer: tf.TensorBuffer<tf.Rank.R2>,\n    offsetsBuffer: tf.TensorBuffer<tf.Rank.R3>): tf.Tensor2D {\n  const result: number[] = [];\n\n  for (let keypoint = 0; keypoint < NUM_KEYPOINTS; keypoint++) {\n    const heatmapY = heatMapCoordsBuffer.get(keypoint, 0).valueOf();\n    const heatmapX = heatMapCoordsBuffer.get(keypoint, 1).valueOf();\n\n    const {x, y} = getOffsetPoint(heatmapY, heatmapX, keypoint, offsetsBuffer);\n\n    result.push(y);\n    result.push(x);\n  }\n\n  return tf.tensor2d(result, [NUM_KEYPOINTS, 2]);\n}\n\nexport function getOffsetPoints(\n    heatMapCoordsBuffer: tf.TensorBuffer<tf.Rank.R2>, outputStride: number,\n    offsetsBuffer: tf.TensorBuffer<tf.Rank.R3>): tf.Tensor2D {\n  return tf.tidy(() => {\n    const offsetVectors = getOffsetVectors(heatMapCoordsBuffer, offsetsBuffer);\n\n    return heatMapCoordsBuffer.toTensor()\n        .mul(tf.scalar(outputStride, 'int32'))\n        .toFloat()\n        .add(offsetVectors);\n  });\n}\n"]}},"hash":"97532bfefe66a5a9f39936df124df514","cacheData":{"env":{}}}