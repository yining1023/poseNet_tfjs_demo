{"dependencies":[{"name":"/Users/yiningshi/dev/tfjs-models/posenet/demos/package.json","includedInParent":true,"mtime":1530912130696},{"name":"/Users/yiningshi/dev/tfjs-models/posenet/demos/.babelrc","includedInParent":true,"mtime":1529855715672},{"name":"/Users/yiningshi/dev/tfjs-models/posenet/tsconfig.json","includedInParent":true,"mtime":1529855715734},{"name":"@tensorflow/tfjs","loc":{"line":38,"column":17}},{"name":"./keypoints","loc":{"line":39,"column":26}}],"generated":{"js":"\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tf = require(\"@tensorflow/tfjs\");\nvar keypoints_1 = require(\"./keypoints\");\nfunction eitherPointDoesntMeetConfidence(a, b, minConfidence) {\n    return (a < minConfidence || b < minConfidence);\n}\nfunction getAdjacentKeyPoints(keypoints, minConfidence) {\n    return keypoints_1.connectedPartIndices.reduce(function (result, _a) {\n        var leftJoint = _a[0], rightJoint = _a[1];\n        if (eitherPointDoesntMeetConfidence(keypoints[leftJoint].score, keypoints[rightJoint].score, minConfidence)) {\n            return result;\n        }\n        result.push([keypoints[leftJoint], keypoints[rightJoint]]);\n        return result;\n    }, []);\n}\nexports.getAdjacentKeyPoints = getAdjacentKeyPoints;\nvar NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY, POSITIVE_INFINITY = Number.POSITIVE_INFINITY;\nfunction getBoundingBox(keypoints) {\n    return keypoints.reduce(function (_a, _b) {\n        var maxX = _a.maxX, maxY = _a.maxY, minX = _a.minX, minY = _a.minY;\n        var _c = _b.position, x = _c.x, y = _c.y;\n        return {\n            maxX: Math.max(maxX, x),\n            maxY: Math.max(maxY, y),\n            minX: Math.min(minX, x),\n            minY: Math.min(minY, y)\n        };\n    }, {\n        maxX: NEGATIVE_INFINITY,\n        maxY: NEGATIVE_INFINITY,\n        minX: POSITIVE_INFINITY,\n        minY: POSITIVE_INFINITY\n    });\n}\nexports.getBoundingBox = getBoundingBox;\nfunction getBoundingBoxPoints(keypoints) {\n    var _a = getBoundingBox(keypoints), minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY = _a.maxY;\n    return [\n        { x: minX, y: minY }, { x: maxX, y: minY }, { x: maxX, y: maxY },\n        { x: minX, y: maxY }\n    ];\n}\nexports.getBoundingBoxPoints = getBoundingBoxPoints;\nfunction toTensorBuffer(tensor, type) {\n    if (type === void 0) { type = 'float32'; }\n    return __awaiter(this, void 0, Promise, function () {\n        var tensorData;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4, tensor.data()];\n                case 1:\n                    tensorData = _a.sent();\n                    return [2, new tf.TensorBuffer(tensor.shape, type, tensorData)];\n            }\n        });\n    });\n}\nexports.toTensorBuffer = toTensorBuffer;\nfunction toTensorBuffers3D(tensors) {\n    return __awaiter(this, void 0, Promise, function () {\n        return __generator(this, function (_a) {\n            return [2, Promise.all(tensors.map(function (tensor) { return toTensorBuffer(tensor, 'float32'); }))];\n        });\n    });\n}\nexports.toTensorBuffers3D = toTensorBuffers3D;\nfunction scalePose(pose, scaleX, scaleY) {\n    return {\n        score: pose.score,\n        keypoints: pose.keypoints.map(function (_a) {\n            var score = _a.score, part = _a.part, position = _a.position;\n            return ({\n                score: score,\n                part: part,\n                position: { x: position.x * scaleX, y: position.y * scaleY }\n            });\n        })\n    };\n}\nexports.scalePose = scalePose;\nfunction scalePoses(poses, scaleY, scaleX) {\n    if (scaleX === 1 && scaleY === 1) {\n        return poses;\n    }\n    return poses.map(function (pose) { return scalePose(pose, scaleX, scaleY); });\n}\nexports.scalePoses = scalePoses;\nfunction getValidResolution(imageScaleFactor, inputDimension, outputStride) {\n    var evenResolution = inputDimension * imageScaleFactor - 1;\n    return evenResolution - (evenResolution % outputStride) + 1;\n}\nexports.getValidResolution = getValidResolution;\n","map":{"version":3,"file":"util.js","sourceRoot":"","sources":["../src/util.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA,qCAAuC;AAEvC,yCAAiD;AAIjD,yCACI,CAAS,EAAE,CAAS,EAAE,aAAqB;IAC7C,OAAO,CAAC,CAAC,GAAG,aAAa,IAAI,CAAC,GAAG,aAAa,CAAC,CAAC;AAClD,CAAC;AAED,8BACI,SAAqB,EAAE,aAAqB;IAC9C,OAAO,gCAAoB,CAAC,MAAM,CAC9B,UAAC,MAAoB,EAAE,EAAuB;YAAtB,iBAAS,EAAE,kBAAU;QAC3C,IAAI,+BAA+B,CAC3B,SAAS,CAAC,SAAS,CAAC,CAAC,KAAK,EAAE,SAAS,CAAC,UAAU,CAAC,CAAC,KAAK,EACvD,aAAa,CAAC,EAAE;YACtB,OAAO,MAAM,CAAC;SACf;QAED,MAAM,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE,SAAS,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAE3D,OAAO,MAAM,CAAC;IAChB,CAAC,EAAE,EAAE,CAAC,CAAC;AACb,CAAC;AAdD,oDAcC;AAEM,IAAA,4CAAiB,EAAE,4CAAiB,CAAW;AACtD,wBAA+B,SAAqB;IAElD,OAAO,SAAS,CAAC,MAAM,CAAC,UAAC,EAAwB,EAAE,EAAkB;YAA3C,cAAI,EAAE,cAAI,EAAE,cAAI,EAAE,cAAI;YAAI,gBAAgB,EAAL,QAAC,EAAE,QAAC;QACjE,OAAO;YACL,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YACvB,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YACvB,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;YACvB,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC;SACxB,CAAC;IACJ,CAAC,EAAE;QACD,IAAI,EAAE,iBAAiB;QACvB,IAAI,EAAE,iBAAiB;QACvB,IAAI,EAAE,iBAAiB;QACvB,IAAI,EAAE,iBAAiB;KACxB,CAAC,CAAC;AACL,CAAC;AAfD,wCAeC;AAED,8BAAqC,SAAqB;IAClD,IAAA,8BAAoD,EAAnD,cAAI,EAAE,cAAI,EAAE,cAAI,EAAE,cAAI,CAA8B;IAC3D,OAAO;QACL,EAAC,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAC,EAAE,EAAC,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAC,EAAE,EAAC,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAC;QAC1D,EAAC,CAAC,EAAE,IAAI,EAAE,CAAC,EAAE,IAAI,EAAC;KACnB,CAAC;AACJ,CAAC;AAND,oDAMC;AAED,wBACI,MAAuB,EACvB,IAAmC;IAAnC,qBAAA,EAAA,gBAAmC;mCAAG,OAAO;;;;wBAC5B,WAAM,MAAM,CAAC,IAAI,EAAE,EAAA;;oBAAhC,UAAU,GAAG,SAAmB;oBAEtC,WAAO,IAAI,EAAE,CAAC,YAAY,CAAO,MAAM,CAAC,KAAK,EAAE,IAAI,EAAE,UAAU,CAAC,EAAC;;;;CAClE;AAND,wCAMC;AAED,2BAAwC,OAAsB;mCAC1D,OAAO;;YACT,WAAO,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,GAAG,CAAC,UAAA,MAAM,IAAI,OAAA,cAAc,CAAC,MAAM,EAAE,SAAS,CAAC,EAAjC,CAAiC,CAAC,CAAC,EAAC;;;CAC9E;AAHD,8CAGC;AAED,mBAA0B,IAAU,EAAE,MAAc,EAAE,MAAc;IAClE,OAAO;QACL,KAAK,EAAE,IAAI,CAAC,KAAK;QACjB,SAAS,EAAE,IAAI,CAAC,SAAS,CAAC,GAAG,CACzB,UAAC,EAAuB;gBAAtB,gBAAK,EAAE,cAAI,EAAE,sBAAQ;YAAM,OAAA,CAAC;gBAC5B,KAAK,OAAA;gBACL,IAAI,MAAA;gBACJ,QAAQ,EAAE,EAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,MAAM,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC,GAAG,MAAM,EAAC;aAC3D,CAAC;QAJ2B,CAI3B,CAAC;KACR,CAAC;AACJ,CAAC;AAVD,8BAUC;AAED,oBACI,KAAa,EAAE,MAAc,EAAE,MAAc;IAC/C,IAAI,MAAM,KAAK,CAAC,IAAI,MAAM,KAAK,CAAC,EAAE;QAChC,OAAO,KAAK,CAAC;KACd;IACD,OAAO,KAAK,CAAC,GAAG,CAAC,UAAA,IAAI,IAAI,OAAA,SAAS,CAAC,IAAI,EAAE,MAAM,EAAE,MAAM,CAAC,EAA/B,CAA+B,CAAC,CAAC;AAC5D,CAAC;AAND,gCAMC;AAED,4BACI,gBAAwB,EAAE,cAAsB,EAChD,YAA0B;IAC5B,IAAM,cAAc,GAAG,cAAc,GAAG,gBAAgB,GAAG,CAAC,CAAC;IAE7D,OAAO,cAAc,GAAG,CAAC,cAAc,GAAG,YAAY,CAAC,GAAG,CAAC,CAAC;AAC9D,CAAC;AAND,gDAMC","sourcesContent":["/**\n * @license\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as tf from '@tensorflow/tfjs';\n\nimport {connectedPartIndices} from './keypoints';\nimport {OutputStride} from './mobilenet';\nimport {Keypoint, Pose, TensorBuffer3D, Vector2D} from './types';\n\nfunction eitherPointDoesntMeetConfidence(\n    a: number, b: number, minConfidence: number): boolean {\n  return (a < minConfidence || b < minConfidence);\n}\n\nexport function getAdjacentKeyPoints(\n    keypoints: Keypoint[], minConfidence: number): Keypoint[][] {\n  return connectedPartIndices.reduce(\n      (result: Keypoint[][], [leftJoint, rightJoint]): Keypoint[][] => {\n        if (eitherPointDoesntMeetConfidence(\n                keypoints[leftJoint].score, keypoints[rightJoint].score,\n                minConfidence)) {\n          return result;\n        }\n\n        result.push([keypoints[leftJoint], keypoints[rightJoint]]);\n\n        return result;\n      }, []);\n}\n\nconst {NEGATIVE_INFINITY, POSITIVE_INFINITY} = Number;\nexport function getBoundingBox(keypoints: Keypoint[]):\n    {maxX: number, maxY: number, minX: number, minY: number} {\n  return keypoints.reduce(({maxX, maxY, minX, minY}, {position: {x, y}}) => {\n    return {\n      maxX: Math.max(maxX, x),\n      maxY: Math.max(maxY, y),\n      minX: Math.min(minX, x),\n      minY: Math.min(minY, y)\n    };\n  }, {\n    maxX: NEGATIVE_INFINITY,\n    maxY: NEGATIVE_INFINITY,\n    minX: POSITIVE_INFINITY,\n    minY: POSITIVE_INFINITY\n  });\n}\n\nexport function getBoundingBoxPoints(keypoints: Keypoint[]): Vector2D[] {\n  const {minX, minY, maxX, maxY} = getBoundingBox(keypoints);\n  return [\n    {x: minX, y: minY}, {x: maxX, y: minY}, {x: maxX, y: maxY},\n    {x: minX, y: maxY}\n  ];\n}\n\nexport async function toTensorBuffer<rank extends tf.Rank>(\n    tensor: tf.Tensor<rank>,\n    type: 'float32'|'int32' = 'float32'): Promise<tf.TensorBuffer<rank>> {\n  const tensorData = await tensor.data();\n\n  return new tf.TensorBuffer<rank>(tensor.shape, type, tensorData);\n}\n\nexport async function toTensorBuffers3D(tensors: tf.Tensor3D[]):\n    Promise<TensorBuffer3D[]> {\n  return Promise.all(tensors.map(tensor => toTensorBuffer(tensor, 'float32')));\n}\n\nexport function scalePose(pose: Pose, scaleX: number, scaleY: number): Pose {\n  return {\n    score: pose.score,\n    keypoints: pose.keypoints.map(\n        ({score, part, position}) => ({\n          score,\n          part,\n          position: {x: position.x * scaleX, y: position.y * scaleY}\n        }))\n  };\n}\n\nexport function scalePoses(\n    poses: Pose[], scaleY: number, scaleX: number): Pose[] {\n  if (scaleX === 1 && scaleY === 1) {\n    return poses;\n  }\n  return poses.map(pose => scalePose(pose, scaleX, scaleY));\n}\n\nexport function getValidResolution(\n    imageScaleFactor: number, inputDimension: number,\n    outputStride: OutputStride): number {\n  const evenResolution = inputDimension * imageScaleFactor - 1;\n\n  return evenResolution - (evenResolution % outputStride) + 1;\n}\n"]}},"hash":"8573f7617a26cb15efe633070ad1a5cd","cacheData":{"env":{}}}